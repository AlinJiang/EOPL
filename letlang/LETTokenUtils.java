package letlang;

import java.util.HashMap;
import java.util.Map;

public class LETTokenUtils {

    public static Map<String, LETTokenType> dispatchTable = null;
    public static int terminalSize;
    
    public LETTokenUtils() {
        if (dispatchTable == null) {
            terminalSize = terminals.length;
            dispatchTable = new HashMap<>(terminalSize);
            for (int i = 0; i < terminalSize; ++i) {
                dispatchTable.put(terminalStrings[i], terminals[i]);
            }
        }
    }
    
    public static boolean isTerminal(String intermediate) {
        for (String tml : terminalStrings) {
            if (intermediate.equals(tml)) {
                return true;
            }
        }
        return false;
    }
    
    public static LETTokenType[] terminals = {
            LETTokenType.MINUS, 
            LETTokenType.COMMA,
            LETTokenType.LPAREN,
            LETTokenType.RPAREN,
            LETTokenType.ZERO_QUESTION,
            LETTokenType.IF,
            LETTokenType.THEN,
            LETTokenType.ELSE,
            LETTokenType.LET,
            LETTokenType.EQUAL,
            LETTokenType.IN,
            LETTokenType.NEGATE,
            LETTokenType.ADD,
            LETTokenType.MUL,
            LETTokenType.QUOTIENT,
            LETTokenType.EQUAL_QUESTION,
            LETTokenType.LESS_QUESTION,
            LETTokenType.GREATER_QUESTION,
            LETTokenType.CONS,
            LETTokenType.CAR,
            LETTokenType.CDR,
            LETTokenType.NULL_QUESTION,
            LETTokenType.EMPTYLIST,
            LETTokenType.LIST,
            LETTokenType.COND,
            LETTokenType.IF_COND,
            LETTokenType.END,
            LETTokenType.LET_STAR,
            LETTokenType.UNPACK,
            LETTokenType.PROC,
            LETTokenType.LETPROC,
            LETTokenType.LETREC,
            LETTokenType.NEWREF,
            LETTokenType.SETREF,
            LETTokenType.DEREF,
            LETTokenType.BEGIN,
            LETTokenType.SET,
            LETTokenType.LETMUTABLE,
            LETTokenType.SETDYNAMIC,
            LETTokenType.DURING,
            LETTokenType.PRINT,
            LETTokenType.WHILE,
            LETTokenType.VAR,
            LETTokenType.NOT,
            LETTokenType.DO,
            LETTokenType.READ,
            LETTokenType.INT,
            LETTokenType.BOOL,
            LETTokenType.DERIVE,
            LETTokenType.SEMICOLON,
            LETTokenType.OPTION, 
            LETTokenType.PRODUCT,
            LETTokenType.COLON,
            LETTokenType.FROM,
            LETTokenType.TAKE,
            LETTokenType.LBRACK,
            LETTokenType.RBRACK,
            LETTokenType.MODULE,
            LETTokenType.INTERFACE,
            LETTokenType.BODY,
            LETTokenType.PAIROF,
            LETTokenType.NEWPAIR,
            LETTokenType.UNPAIR,
            LETTokenType.UNDERSCORE,
            LETTokenType.LISTOF,
            LETTokenType.VOID,
            LETTokenType.OPAQUE,
            LETTokenType.TRANSPARENT,
            LETTokenType.TYPE,
            LETTokenType.MODULE_PROC,
            LETTokenType.CLASS,
            LETTokenType.EXTENDS,
            LETTokenType.FIELD,
            LETTokenType.METHOD,
            LETTokenType.NEW,
            LETTokenType.SEND,
            LETTokenType.SUPER,
            LETTokenType.SELF,
            LETTokenType.IMPLEMENTS,
            LETTokenType.CAST,
            LETTokenType.INSTANCEOF,
            LETTokenType.INTERFACEDERIVE,
    };
    
    public static String[] terminalStrings = {
            "-", 
            ",",
            "(",
            ")",
            "zero?",
            "if",
            "then",
            "else",
            "let",
            "=",
            "in",
            "minus", 
            "add",
            "mul",
            "quotient",
            "equal?",
            "less?",
            "greater?",
            "cons",
            "car",
            "cdr",
            "null?",
            "emptylist",
            "list",
            "cond",
            "==>",
            "end",
            "let*",
            "unpack",
            "proc",
            "letproc",
            "letrec",
            "newref",
            "setref",
            "deref",
            "begin",
            "set",
            "letmutable",
            "setdynamic",
            "during",
            "print",
            "while",
            "var",
            "not",
            "do",
            "read",
            "int",
            "bool",
            "->",
            ";",
            "?",
            "*",
            ":",
            "from",
            "take",
            "[",
            "]",
            "module",
            "interface",
            "body",
            "pairof",
            "newpair",
            "unpair",
            "_",
            "listof",
            "void",
            "opaque",
            "transparent",
            "type",
            "moduleproc",
            "class",
            "extends",
            "field",
            "method",
            "new",
            "send",
            "super",
            "self",
            "implements",
            "cast",
            "instanceof",
            "=>",
    };
    
}
